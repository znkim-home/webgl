var attributes = ["aVertexPosition", "aTextureCoordinate"];
var uniforms = ["uIsMain", "uSsaoKernel", "uScreenSize", "uNoiseScale",
    "uAspectRatio", "uProjectionMatrix", "uTangentOfHalfFovy", "uNearFar",
    "uMainTexture", "uAlbedoTexture", "uSelectionTexture", "uNormalTexture",
    "uDepthTexture", "uNoiseTexture", "uLightMapTexture", "uCameraTransformMatrix", "uSunModelViewMatrix", "uOrthographicMatrix", "uSunNormalMatrix",
    "uEnableGlobalLight", "uEnableEdge", "uEnableSsao", "uSelectedObjectId"];
var vertexShaderSource = "\n  #pragma vscode_glsllint_stage : vert\n  attribute vec3 aVertexPosition;\n  attribute vec2 aTextureCoordinate;\n\n  varying vec2 vTextureCoordinate;\n  void main(void) {\n    vTextureCoordinate = aTextureCoordinate;\n    gl_Position = vec4(aVertexPosition.xy * 2.0 - 1.0, 0.0, 1.0);\n  }\n";
var fragmentShaderSource = "\n  #pragma vscode_glsllint_stage : frag\n  precision highp float;\n  \n  uniform int uIsMain;\n  uniform float uTangentOfHalfFovy;\n  uniform float uAspectRatio;\n\n  uniform vec2 uScreenSize;  \n  uniform vec2 uNearFar;\n  uniform vec2 uNoiseScale;\n  uniform mat4 uProjectionMatrix;\n  uniform mat4 uCameraTransformMatrix;\n  uniform mat4 uSunModelViewMatrix;\n  uniform mat4 uOrthographicMatrix;\n  uniform mat4 uSunNormalMatrix;\n\n  uniform sampler2D uMainTexture;\n  uniform sampler2D uAlbedoTexture;\n  uniform sampler2D uSelectionTexture;\n  uniform sampler2D uNormalTexture;\n  uniform sampler2D uDepthTexture;\n  uniform sampler2D uLightMapTexture;\n  uniform sampler2D uNoiseTexture;\n  uniform vec3 uSsaoKernel[16];\n\n  uniform int uEnableGlobalLight;\n  uniform int uEnableEdge;\n  uniform int uEnableSsao;\n  uniform float uSelectedObjectId;\n\n  varying vec2 vTextureCoordinate;\n  \n  const int kernelSize = 16;\n  const float fKernelSize = float(kernelSize);\n\n  vec4 decodeNormal(in vec4 normal) {\n    return vec4(normal.xyz * 2.0 - 1.0, normal.w);\n  }\n  float convertColorToId(vec4 color) {\n    return (color.r * 255.0 * 16777216.0) + (color.g * 255.0 * 65536.0) + (color.b * 255.0 * 256.0) + (color.a * 255.0);\n  }\n  float unpackDepth(vec4 packedDepth) {\n    return dot(packedDepth, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n  }\n  vec3 getViewRay(vec2 tc, in float relFar) {\n    float hfar = 2.0 * uTangentOfHalfFovy * relFar;\n    float wfar = hfar * uAspectRatio;    \n    vec3 ray = vec3(wfar * (tc.x - 0.5), hfar * (tc.y - 0.5), -relFar);    \n    return ray;\n  }\n  vec4 getAlbedo(vec2 screenPos) {\n    return texture2D(uAlbedoTexture, screenPos);\n  }\n  vec4 getSelection(vec2 screenPos) {\n    return texture2D(uSelectionTexture, screenPos);\n  }\n  vec4 getNormal(vec2 screenPos) {\n    return texture2D(uNormalTexture, screenPos);\n  }\n  vec4 getDepth(vec2 screenPos) {\n    //return texture2D(uLightMapTexture, screenPos);\n    return texture2D(uDepthTexture, screenPos);\n  }\n\n  float getOcclusion(vec3 origin, vec3 rotatedKernel, float radius) {\n    float resultOcclusion = 1.0;\n    vec3 sample = origin + (rotatedKernel * radius);\n    vec4 offset = uProjectionMatrix * vec4(sample, 1.0);\n    vec3 offsetCoord = vec3(offset.xyz);\t\t\t\t\n    offsetCoord.xyz /= offset.w;\n    offsetCoord.xyz = offsetCoord.xyz * 0.5 + 0.5;\n    if ((abs(offsetCoord.x) > 1.0 || abs(offsetCoord.y) > 1.0) && (abs(offsetCoord.x) < 0.0 || abs(offsetCoord.y) < 0.0)) {\n        resultOcclusion = 0.0;\n    } else {\n      float depthBufferValue = unpackDepth(texture2D(uDepthTexture, offsetCoord.xy));\n      float sampleZ = -sample.z;\n      float bufferZ = depthBufferValue * uNearFar.y;\n      float zDiff = abs(bufferZ - sampleZ);\n      if (zDiff < radius) {\n        if (bufferZ < sampleZ) {\n          resultOcclusion = 0.0;\n        }\n      }\n    }\n    return resultOcclusion;\n  }\n\n  vec4 getSSAO(in vec2 screenPos) {\n    float occlusionA = 0.0;\n    float occlusionB = 0.0;\n    float occlusionC = 0.0;\n\n    float linearDepth = unpackDepth(getDepth(screenPos));\n    float originDepth = linearDepth * uNearFar.y;\n    vec3 origin = getViewRay(screenPos, originDepth);\n    vec3 normal = decodeNormal(texture2D(uNormalTexture, screenPos)).xyz;\n\n    vec3 rvec = texture2D(uNoiseTexture, screenPos.xy * uNoiseScale).xyz * 2.0 - 1.0;\n\t\tvec3 tangent = normalize(rvec - normal * dot(rvec, normal));\n\t\tvec3 bitangent = normalize(cross(normal, tangent));\n\t\tmat3 tbn = mat3(tangent, bitangent, normal);   \n\t\tfor (int i = 0; i < kernelSize; i++) {    \t\n      vec3 rotatedKernel = tbn * vec3(uSsaoKernel[i].x, uSsaoKernel[i].y, uSsaoKernel[i].z);\n      occlusionA += getOcclusion(origin, rotatedKernel, 8.5);\n      occlusionB += getOcclusion(origin, rotatedKernel, 16.0);\n      occlusionC += getOcclusion(origin, rotatedKernel, 32.0);\n    }\n\n    float tolerance = 0.80;\n    float result = (occlusionA + occlusionB + occlusionC) / (fKernelSize * 3.0);\n    if (result > tolerance) {\n      result = 1.0;\n    }\n    //return result;\n\n    return vec4(occlusionA / fKernelSize, occlusionB / fKernelSize, occlusionC / fKernelSize, 1.0);\n  }\n\n  float compareNormalOffset(in vec4 normalA, in vec4 normalB) {\n    float result = 0.0; \n    result += abs(normalA.x - normalB.x);\n    result += abs(normalA.y - normalB.y);\n    result += abs(normalA.z - normalB.z);\n    return result;\n  }\n\n  bool isEdge(vec2 screenPos) {\n    float width = 1.0 / uScreenSize.x;\n\t  float height = 1.0 / uScreenSize.y;\n    vec2 rightPos = vec2(screenPos.x + width, screenPos.y);\n    vec2 bottomPos = vec2(screenPos.x, screenPos.y + height);\n    vec2 crossPos = vec2(screenPos.x + width, screenPos.y + height);\n    vec2 leftPos = vec2(screenPos.x - width, screenPos.y);\n    \n    float selection = convertColorToId(getSelection(screenPos));\n    float selectionRight = convertColorToId(getSelection(rightPos));\n    float selectionBottom = convertColorToId(getSelection(bottomPos));\n    float selectionCross = convertColorToId(getSelection(crossPos));\n    float selectionLeft = convertColorToId(getSelection(leftPos));\n\n    vec4 normal = decodeNormal(getNormal(screenPos));\n    vec4 normalRight = decodeNormal(getNormal(rightPos));\n    vec4 normalBottom = decodeNormal(getNormal(bottomPos));\n    vec4 normalCross = decodeNormal(getNormal(crossPos));\n\n    float compareOffset = 0.3;\n    bool normalCompareRight = compareOffset < compareNormalOffset(normal, normalRight);\n    bool normalCompareBottom = compareOffset < compareNormalOffset(normal, normalBottom);\n    bool normalCompareCross = compareOffset < compareNormalOffset(normal, normalCross);\n\n    bool isEdgeByNormalCompare = normalCompareRight || normalCompareBottom || normalCompareCross;\n    bool isEdgeBySelection = selection != selectionBottom || selection != selectionRight || selection != selectionCross || selection != selectionLeft;\n\n    return isEdgeByNormalCompare || isEdgeBySelection;\n  }\n\n  bool isShadow(vec2 screenPos) {\n    bool result = false;\n\n    float linearDepth = unpackDepth(getDepth(screenPos));\n    float originDepth = linearDepth * uNearFar.y;\n    vec3 positionCC = getViewRay(screenPos, originDepth);\n    vec4 positionWC = uCameraTransformMatrix * vec4(positionCC, 1.0);\n    vec4 positionSC = uSunModelViewMatrix * vec4(positionWC.xyz, 1.0);\n\n    positionSC = uOrthographicMatrix * positionSC;\n    vec3 positionUnitarySCaux = positionSC.xyz / positionSC.w; // Range : -1.0 ~ 1.0\n    vec3 positionUnitarySC = positionUnitarySCaux * 0.5 + 0.5; // Range = 0.0 ~ 1.0\n\n    if (positionUnitarySC.z > 0.9999) {\n      return result;\n    }\n    if (positionUnitarySC.x > 1.0 || positionUnitarySC.x < 0.0 || positionUnitarySC.y > 1.0 || positionUnitarySC.y < 0.0) {\n      return result;\n    }\n\n    vec4 fromDepthSunTextureVec4 = texture2D(uLightMapTexture, positionUnitarySC.xy) ;\n    fromDepthSunTextureVec4 = fromDepthSunTextureVec4 * 1.001;\n    float fromDepthSunTexture = unpackDepth(fromDepthSunTextureVec4);\n\n    result = positionUnitarySC.z > fromDepthSunTexture;\n    return result;\n  }\n\n  void main(void) {\n    float width = 1.0 / uScreenSize.x;\n\t  float height = 1.0 / uScreenSize.y;\n    vec2 screenPos = vec2(gl_FragCoord.x / uScreenSize.x, gl_FragCoord.y / uScreenSize.y);\n\n    vec4 albedo = getAlbedo(screenPos);\n    vec4 normal = decodeNormal(getNormal(screenPos));\n\n    vec4 selectionColor = getSelection(screenPos);\n    float selection = convertColorToId(getSelection(screenPos));\n\n    vec3 ambientLight = vec3(0.3, 0.3, 0.3);\n    vec3 directionalLightColor = vec3(0.9, 0.9, 0.9);\n    vec3 directionalVector = normalize(vec3(0.6, 0.6, 0.9));\n    float directional = max(dot(normal.xyz, directionalVector), 0.0);\n    vec3 vLighting = ambientLight + (directionalLightColor * directional);\n\n    if (uIsMain == 1) {\n      vec3 result = albedo.xyz;\n      \n      if (uEnableSsao == 1) {\n        //float ssaoResult = getSSAO(screenPos);\n        float tolerance = 0.80;\n        vec4 ssaoResult = getSSAO(screenPos);\n\n        if (ssaoResult.x < tolerance) {\n          result = result * ssaoResult.x;\n        }\n        if (ssaoResult.y < tolerance) {\n          result = result * (ssaoResult.y + 0.1);\n        }\n        if (ssaoResult.z < tolerance) {\n          result = result * (ssaoResult.z + 0.2);\n        }\n        //result = result * ssaoResult;\n      }\n\n      //result = result * vLighting;\n      if (uEnableGlobalLight == 1 && isShadow(screenPos)) {\n        result = result * 0.5;\n      }\n\n      if (selection == uSelectedObjectId) {\n        result.b = result.b * 1.5;\n      }\n      if (uEnableEdge == 1 && isEdge(screenPos)) {\n        result = result * 0.5;\n        if (selection == uSelectedObjectId) {\n          result.b = 1.0;\n        }\n      }\n      gl_FragColor = vec4(result, 1.0);\n    } else {\n      vec4 textureColor = texture2D(uMainTexture, vTextureCoordinate);\n      gl_FragColor = vec4(textureColor.rgb, textureColor.a);\n    }\n  }\n";
export var ScreenShader = {
    attributes: attributes,
    uniforms: uniforms,
    vertexShaderSource: vertexShaderSource,
    fragmentShaderSource: fragmentShaderSource,
};
